\chapter{Kryptographische Basics}

Kryptographie beschreibt die Technik (und Kunst) über nicht-vertrauenswürdige Kanäle bzw. Speicherorte Daten integritäts- und vertraulichkeitsgesichert zu übertragen. Dadurch kann Kryptographie als Mittel gegen \textit{spoofing}, \textit{tampering}, \textit{repudiation} und \textit{information disclosure} dienen. Dieses Kapitel soll eine (extrem) kurze Einführung in die, in diesem Dokument, verwendeten Konzepte geben.

Grundlegend sollten folgende Grundsätze bei der Verwendung von Kryptographie beachtet werden:

\begin{itemize}
	\item Niemals selbst ein kryptographisches System entwerfen, sondern immer ein etabliertes (und getestetes) System verwenden.
	\item Niemals selbst einen kryptographischen Algorithmus/Bibliothek schreiben, sondern immer etablierte und getestet Komponenten verwenden.
	\item Die richtige kryptographische Methode wählen.
	\item Immer davon ausgehen, dass der eigene Source Code früher oder später öffentlich wird. Aus diesem Grund darf ein kryptographischer Schlüssel (oder auch Credentials) niemals Teil des Source Codes werden.
	\item Nicht auf das Key Management (inklusive Key Revocation) vergessen.
\end{itemize}

Jede implementierte und konfigurierbare kryptographische Methode erhöht potentiell die Angriffsoberfläche. Ein Beispiel hierfür ist z. B. die OpenSSL-Bibliothek die dutzende Algorithmen implementiert. Als Alternative sind in den letzten Jahren kryptographische Bibliotheken wie \textit{NaCl} (``salt'') entstanden, die für jede kryptographische Methode genau eine sichere Implementierung anbieten. Auf diese Weise sollen Selektionsfehler durch Entwickler vermieden werden.

Ein häufiger verwendeter Begriff ist \textit{Rubber Hose Cryptography}. Ein noch so technisch sicheres kryptographisches System kann durch bezahlte Schläger mit einem Gummischlauch und der Androhung von Gewalt, falls das Opfer nicht den privaten Schlüssel mitteilt, günstig gebrochen werden. Anstatt durch Androhung von Gewalt kann \textit{Rubber Hose Cryptography} auch auf andere Aspekte eines Schlüsselträgers abzielen: Geld, Ideologie, Coersion oder Ego (Sex sells).

\section{Grundlegende Kryptographische Methoden}

Zur Wahrung der Vertraulichkeit von Daten wird Verschlüsselung eingesetzt. Bei dieser wird der Originaltext (engl. plain-text) in einen verschlüsselten Text (engl. cipher-text) konvertiert. Dieser kann wieder durch den Entschlüsselungs-Vorgang in den Originaltext zurück verwandelt werden. Verschlüsselungsalgorithmen können in zwei Familien eingeteilt werden: symmetrisch und asymmetrisch (auch public-key encryption genannt). Bei symmetrischer Verschlüsselung wird zum ver- und entschlüsseln der idente Schlüssel verwendet. Problematisch hierbei ist, dass dieser geteilte geheime Schlüssel initial zwischen allen Beteiligten verteilt werden muss. Bei der asymmetrischen Verschlüsselung wird statt einem geteilten Schlüssel ein Schlüsselpaar\footnote{Das Schlüsselpaar ist mathematisch ``verwandt''.} verwendet. Dieses besteht aus einem öffentlichen Schlüssel der zur Verschlüsselung dient und einem zugehörigen privaten Schlüssel der zum Entschlüsseln verwendet wird. Dadurch wird die Problematik des initialen Schlüsselverteilens entschärft, da nur öffentliche Schlüssel verteilt werden müssen (diese dürfen veröffentlicht bzw. verloren werden). Ein Nachteil asymmetrischer Verschlüsselung gegenüber symmetrischer Verschlüsselung ist, dass sie langsamer als symmetrische Verschlüsselung ist.

Eine weitere Unterscheidungsmöglichkeit für Verschlüsselungsalgorithmen ist die in \textit{block} und \textit{stream} ciphers. Bei Blockciphern werden zuerst Daten angehäuft (``ein Block'' an plain-data) und dann dieser Block verschlüsselt. Bei einem Streamcipher wird jedes Zeichen sofort verschlüsselt, das Sammeln von Blocken wird so vermieden. Während Stream-Ciphers teilweise einfacher für Programmierer in ihrer Verwendung sind, werden aus Effizienzgründen fast ausschließlich Blockcipher verwendet. Werden zwei idente Blöcke mit dem identen Schlüssel verschlüsselt, würden idente verschlüsselte Blöcke entstehen. Dies erlaubt es einem Angreifer, strukturelle Informationen aus verschlüsselten Dokumenten zu extrahieren. Um dies zu vermeiden werden sogenannte \textit{Block Modes} verwendet um sicherzustellen, dass idente plain-text Blöcke unterschiedliche cipher-text Blöcke produziernen. Bie Auswahl des Block Modes sollten GCM-Modes (bzw. AEAD-Varianten) bevorzugt und ECB bzw. CBC Modes vermieden werden.

Verschlüsselung gewährleistet nicht automatisch die Integrität der verschlüsselten Daten. Hierfür müssen eigene Algorithmen verwendet werden. Häufig vorgefunden werden Hashes, Message Authentication Codes (MACs) und Signaturen. Vereinfacht ausgedruckt berechnen Hashes ausgehend von beliebig langen Eingangsdaten eine Checksumme konstanter Größe. Wird ein Hash auf identen Eingangsdaten angewandt, wird auch ein identer Hash berechnet. Ein Hash ist eine Einwegfunktion: während der zugehörige Hash zu einem Eingangsdatum schnell berechnet werden kann (gegeben den ursprünglichen Daten), ist das Berechnen der Eingangsdaten ausgehend von einem Hash realistisch nicht möglich.

Bei einem Message Authentication Code (MAC) wird der Hash um ein geheimes geteiltes Passwort erweitert. Zur Berechnung bzw. Validierung eines MACs wird dieses Passwort benötigt. Analog zur symmetrischen Verschlüsselung ergibt sich hier die Problematik der Schlüsselverteilung. Signaturen lösen dieses Problem indem sie asymmetrische (public-key) Verschlüsselung einsetzen. Bei ihnen kann die Checksumme (Signature) mit Hilfe des privaten Schlüssels erstellt und mit Hilfe des öffentlichen Schlüssels verifiziert werden. Dadurch entfällt das Problem der Schlüsselverteilung, allerdings wird auch hier der Vorteil durch geringere Geschwindigkeit erkauft.

Je nach Einsatzbereich muss nun ein geeignetes Verfahren zur Integritätssicherung und Verschlüsselung gewählt werden. Werden Daten über ein öffentliches bzw. feindliches Netzwerk transferiert ist z. B. der Einsatz eines Hashes problematisch. Falls ein Angreifer einen Datensatz abfangen und modifizieren kann, kann er ebenso einen neuen Hash berechnen und so den Integritätsschutz umgehen. Bei diesem Beispiel wäre der Einsatz eines MACs oder von Signaturen sinnvoller.

Bei der korrekten Verwendung von kryptographischen Methoden ist der Einsatz guter Zufallszahlengenerator essentiell. Dieser sollte Zufallszahlen mit hoher Entropie generieren. Dies kann z. B. durch Einsatz eines Hardware-Zufallsgenerators sichergestellt werden. Ist ein solcher nicht verfügbar, muss ein kryptographisch sicherer Pseudo-Zufallszahlengenerator (PRNG) verwendet werden.

\section{Weitere Informationsquellen}

Entwickler benötigen Guidance zur Selektion der jeweiligen kryptographischen Algorithmen, hier eine kleine Auswahl öffentlich verfügbarer Dokumente:

\begin{enumerate}
	\item Das amerikanische NIST gibt Empfehlungen für Cryptographical Standards ab, z. B. SP-800-175B\footnote{\url{https://csrc.nist.gov/publications/detail/sp/800-175b/final}}. Aufgrund der Zusammenarbeit des NIST mit der amerikanischen NSA bei zu vorigen Crypto-Standards (Vermutung der Platzierung einer Backdoor in einen Random-Number-Generator) wird mittlerweile gerne von den NIST-Empfehlungen abgesehen.
	\item Die europäische ENISA gibt regelmäßig Empfehlungen zu verwendeten kryptographischen Standards und Schlüssellängen ab (\textit{Algorithms, key size and parameter report 2014}\footnote{\url{https://www.enisa.europa.eu/publications/algorithms-key-size-and-parameters-report-2014}}. Während diese relativ gut sind, ist die Frequenz der Veröffentlichung für IT-Verhältnisse etwas behäbig (4-5 Jahre).
	\item Das deutsche Bundesamt für Sicherheit in der Informationstechnik (BSI) bietet häufig überarbeitete Empfehlungen zum Einsatz kryptographischer Methoden an (BSI TR-02102\footnote{\url{https://www.bsi.bund.de/DE/Publikationen/TechnischeRichtlinien/tr02102/index_htm.html}}). Diese sind relativ aktuell und klassifizieren Algorithmen in sichere Algorithmen die bei aktuellen Neuentwicklungen verwendet werden sollen und in legacy-Algorithmen, die zwar nicht mehr bei Neuentwicklungen verwendet werden sollten, die aber bei bestehender Software durchaus weiterverwendet werden können.
	\item das BetterCrypto.org\footnote{\url{https://www.bettercrypto.org}} bietet regelmäßig upgedatete Beispielskonfigurationen für geläufige Webserver. Diese sollten dazu dienen, dass ein Administrator diese Snippets direkt in die Konfiguration eines Webservers kopieren können und dadurch eine sichere Konfiguration erreicht wird.
\end{enumerate}

\chapter{Speicherung von Passwörtern}
\label{password_storage}

Werden Passwörter durch die Applikation verarbeitet bzw. gespeichert müssen diese besonders geschützt werden. Der Grundsatz ist, dass Passwörter niemals plaintext gespeichert werden dürfen. Dies inkludiert alle Logdateien, Debug-Logs, etc. Die meisten Frameworks besitzen Möglichkeiten sensitive Felder (wie Passwortfelder) explizit vom Logging auszunehmen.

\section{Sichere Speicherung von Passwörtern}

Wenn Credentials unbedingt innerhalb der Applikation gespeichert werden müssen, sind Schutzmaßnahmen für deren Vertraulichkeit unabdingbar. Sie dürfen niemals in plain-text (unverschlüsselt) persistiert werden, sondern sollten so früh wie möglich mittels einer Einwegfunktion transformiert werden. Dies sollte innerhalb der Applikation und nicht erst z. B. in einer nachgelagerten Datenbank geschehen. Würde dies z. B. mittels eines Datenbanktriggers durchgeführt werden, muss die Applikation das Passwort an die DB übergeben: falls die DB nun das Passwort unsicher bearbeitet oder speichert (DB-Logs, Journal, Fehlerlogs) kann dies durch die Applikation nicht beeinflusst werden.

Als Einwegfunktion wird zumeist eine kryptographische Hash-Variante verwendet. Da Hashes auf deren Geschwindigkeit hin optimiert wurden, sind diese eigentlich suboptimal für Passwort-Hashing geeignet: durch diese Optimierung kann ein Angreifer ebenso effizient einen Brute-Force-Angriff durchführen. Aus diesem Grund sind Key-Derivation-Functions (KDFs) vorzuziehen. Dies sind Verfahren, die ``konfigurierbar langsam'' sind. Sie werden so langsam konfiguriert, dass sie im Normalbetrieb noch keinen übertriebenen negativen Impact auf die Performance besitzen, aber gleichzeitig wirkungsvoll Brute-Force-Angriffe unterbinden. Beispiele für KDFs sind \textit{PDKDF2}, \textit{bcrypt} und \textit{scrypt}.

Werden Hashes extrahiert können offline Brute-Force Angriffe gegen diese Hashes verwendet werden. Diese verwenden meistens multiple Grafikkarten und benötigen keine online Verbindung zu der Online-Applikation. Die dabei erreichten Geschwindigkeiten sind um eine Vielzahl höher als die bei Online-Brute Force Angriffen erreichte Geschwindigkeit.

\section{Umgang mit Credentials in Frameworks}

Innerhalb von Anwendungen müssen häufig Zugangsdaten für Fremdsysteme verwaltet werden, beispielsweise verwenden die meisten Applikationsserver im Hintergrund einen Datenbankserver oder einen Mailserver. Die Zugangsdaten für diese Server müssen in der Applikation hinterlegt werden. Geschieht dies direkt im Source Code erlangt jeder Angreifer mit dem Zugriff auf den Source Code Zugriff auf diese Zugangsdaten. Häufig geschieht es, dass solche Source Code Repositories auf privaten Versionierungsservern (VCS, Version Control Systems, wie z. B. Subversion oder Git) gespeichert, und durch eine (kurzfristige) Fehlkonfiguration diese Daten öffentlich verfügbar gemacht werden. Aus diesem Grund sollten niemals Credentials unverschlüsselt in Source Code Repositories gespeichert werden.

Als Beispiel wird hier kurz das Credential-Konzept von Ruby on Rails (Version 5.2) vorgestellt. Innerhalb des Repositories gibt es eine Datei \textit{credentials.yml.enc} in welcher Credentials bzw. private Schlüssel abgelegt werden können. Diese Datei wird immer verschlüsselt, der Entschlüsselungsschlüssel wird unter \textit{config/master.key} gespeichert und wird nicht in der Versionskontrolle eingecheckt (bzw. wird dieses File explizit mittels \textit{.gitignore} von der Versionskontrolle ausgenommen). Entwickler müssen diesen Schlüssel manuell zwischen den Entwicklungsworkstations kopieren, beim Deployen auf einen Server kann dieser Schlüssel z. B. über eine Umgebungsvariable dem Webserver mitgeteilt werden. Innerhalb des Ruby on Rails Sourcecodes kann man über die Variable \textit{Rails.credentials.key} auf den Schlüssel \textit{key} zugreifen (der innerhalb des verschlüsselten Credential-File hinterlegt ist), mittels der Kommandozeilenoperation \textit{rails credentials:edit} kann man die (kurzfristig) entschlüsselten Credentials editieren. Auf diese Weise wird sichergestellt, dass falls ein Angreifer ein Backup oder Source-Code Repository erbeutet, dieser trotzdem nicht auf die sensiblen Credentials Zugriff erhält.

\chapter{Transportlevel-Sicherheit}

Eine Webapplikation sollte immer und ausschließlich über das gesicherte HTTPS-Protokoll kommunizieren. Um die Sicherheit des Transports zu gewährleisten sollte TLS (ältere und unsichere Versionen hießen SSL) eingesetzt werden.

Beim Einsatz von TLS sollte eine aktuelle Version (aktuell TLSv1.2) verwendet werden, innerhalb von TLS sollten sichere Algorithmen (AES-256-GCM oder ChaCha20-Poly1305) bereitgestellt werden. Aktuell wird TLSv1.2 von ca. 95-96\% der Webserver angeboten. Jeder HTTP/2 kompatible Client muss ebenso TLSv1.2 unterstützen.

Wenn möglich sollten ältere TLS-Versionen vermieden werden, da dadurch schlechtere Kryptographie in kauf genommen werden muss. So schreibt der TLS-Standard vor Version 1.2 vor, dass der Cipher \textit{3DES-CBC} zwingend in einer Standard-konformen Implementierung angeboten werden muss. Dieser Cipher ist zwar noch sicher, wird aber teilweise schon als \textit{legacy} klassifiziert --- sollte also bei neuen Implementierungen nicht mehr verwendet werden. Mit TLSv1.2 wird nicht mehr \textit{3DES-CBC} sondern \textit{AES-128-CBC} als notwendiger Cipher vorgeschrieben. Mit TLSv1.3 wurde der CBC-Modus entfernt: dies ist aus Sicherheitssicht stark begrüßenswert, allerdings ist diese Version des Standards noch nicht veröffentlicht.

Die Entwickler und Administratoren müssen darauf achten, dass alle Kommunikationswege auf die gleiche Art und Weise geschützt werden. Eine Situation, die vermieden werden muss, ist z. B. dass ein Webserver mit einer sicheren TLS-Konfiguration konfiguriert wurde, aber die identen Operationen mittels eines Webservices ungesichert über HTTP bereitgestellt werden.

Ein häufiger Diskussionspunkt ist, welche Verbindungen durch TLS abgesichert und verschlüsselt werden müssen. Prinzipiell sollte jegliche Übertragung über öffentliche Kanäle gesichert erfolgen. Der Einsatz von Verschlüsselung innerhalb des Rechenzentrums, z. B. zwischen Applikationsserver und Datenbanken, wird allerdings teilweise stark diskutiert. Die Verwendung der Verschlüsselung bewirkt geringere Performance, höhere Kosten und verhindert teilweise die Verwendung anderer Sicherheitstechniken (z. B. von Network-based IDSen) --- daher wird teilweise ein Rechenzentrum als a-priori sicher angenommen und innerhalb dessen nicht verschlüsselt. Die jeweilige Entscheidung muss dokumentiert und durch das Management unterzeichnet werden.

\section{Perfect Forward Secrecy}

Perfect Forward Secrecy (PFS) ist eine optionale Eigenschaft von Key-Exchange Protokollen und kann z. B. bei TLS zum Einsatz kommen. TLS verwendet einen Langzeitschlüssel --- während des Verbindungsaufbau wird basierend auf diesem ein Sitzungsschlüssel ausgemacht. Zeichnet ein Angreifer die verschlüsselte Kommunikation auf und erhält auf irgendeine Weise den Langzeitschlüssel, kann er die Verschlüsselung aufbrechen. Dies ist problematisch, da der Langzeitschlüssel auch Jahre nach der eigentlich erfolgten Kommunikation verloren gehen könnte.

Bei Verwendung von PFS kann mit dem Langzeitschlüssel der Sitzungsschlüssel nicht mehr rekonstruiert werden. Dadurch wird die Gefahr einer späteren Offenlegung der Kommunikation durch Verlust des Langzeitschlüssels gebannt.

\section{HSTS}
\label{hsts}

Der \textit{HTTP Strict Transport Security} (HSTS, RFC 6797) Header teilt dem Webbrowser mit, dass Folgezugriffe auf die Webseite immer über ein sicheres Protokoll zu erfolgen haben. Bei Angabe des Headers wird eine Laufzeit in Sekunden (z. B. 31536000 entspricht einem Jahr) für diese Regel angegeben:

\begin{minted}{text}
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
\end{minted}

Sobald dieser Header vom Browser interpretiert wird, werden potentielle zukünftige HTTP-Aufrufe automatisch vom Browser auf HTTPS hochgestuft. Zusätzlich schützen Webbrowser (bei Verwendung von HSTS) Benutzer vor dämlichen Entscheidungen und erlauben nicht mehr das Akzeptieren von defekten oder invaliden Zertifikaten.

HSTS kann durch zwei Optionen erweitert werden. Durch \textit{includeSubDomains} inkludiert Subdomains in den HSTS Schutz. Dies ist wichtig, da ein Angreifer von einer Subdomain auf die Cookies der Hauptdomain zugreifen kann und dadurch auf HSTS-geschützte Cookies zugreifen könnte.

Durch das Setzen von \textit{preload} wird der Wunsch der Webseite mitgeteilt in Google Chrome's HTTPS preload Liste aufgenommen zu werden\footnote{Genauere Informationen können unter \url{https://hstspreload.org/} gefunden werden.}. Dies ist eine Liste von Webseiten, die nur über HTTPS verfügbar sind. Wird dieser Header gesetzt, ist die Seite effektiv über Chrome nie wieder über HTTP erreichbar.

\section{WebSockets}

Eine WebSocket-URL beinhaltet das zu verwendende Protokoll, dieses kann entweder \textit{ws} (WebSocket) oder \textit{wss} (WebSocket Secure) sein. Aus Sicherheitssicht ist natürlich nur \textit{wss} eine valide Antwort.

